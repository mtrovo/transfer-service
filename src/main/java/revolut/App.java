/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package revolut;

import com.google.gson.Gson;
import com.moandjiezana.toml.Toml;
import io.netty.handler.codec.http.HttpResponseStatus;
import java.io.InputStream;
import java.time.Duration;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.reactivestreams.Publisher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;
import reactor.netty.http.server.HttpServer;
import org.sql2o.Sql2o;
import reactor.netty.http.server.HttpServerRequest;
import reactor.netty.http.server.HttpServerResponse;
import revolut.models.CreateAccountRequest;
import revolut.models.CreateDepositRequest;
import revolut.models.CreateTransferRequest;

public class App {

  static final Logger logger = LoggerFactory.getLogger(App.class);

  Gson gson = new Gson();
  final AccountController accountController;

  public App(AccountController accountController) {
    this.accountController = accountController;
  }

  public void run() {
    HttpServer.create()
        .port(8080)
        .route(routes ->
            routes
                .post("/accounts", startPipeline(this::createAccount))
                .get("/accounts/{accountID}", startPipeline(this::getAccount))
                .post("/accounts/{accountID}/deposits", startPipeline(this::createDeposit))
                .post("/accounts/{fromAccount}/transfers", startPipeline(this::createTransfer)
                ))
        .bindUntilJavaShutdown(Duration.ofSeconds(5), server -> {
          logger.info("Server started at {}:{}\n", server.host(), server.port());
        });
  }

  private BiFunction<? super HttpServerRequest, ? super HttpServerResponse, ? extends Publisher<Void>> startPipeline(
      BiFunction<? super HttpServerRequest, ? super HttpServerResponse, ? extends Mono<?>> fn) {
    return (req, resp) -> {
      Mono<?> result = fn.apply(req, resp);
      return handler(resp, result);
    };
  }

  private Publisher<Void> handler(HttpServerResponse resp, Mono<?> result) {
    Mono<Publisher<Void>> trySend = result.map(gson::toJson)
        .map(str -> resp.sendString(Mono.just(str)));
    return errorHandler(resp, trySend)
        .switchIfEmpty(Mono.just(Mono.defer(resp::sendNotFound)))
        .flux()
        .flatMap(it -> it);
  }

  private Mono<Publisher<Void>> errorHandler(HttpServerResponse resp,
      Mono<Publisher<Void>> pipeline) {
    return pipeline
        .onErrorResume(AccountNotFound.class, basicErrorHandler(resp, HttpResponseStatus.NOT_FOUND))
        .onErrorResume(InsufficientFunds.class,
            basicErrorHandler(resp, HttpResponseStatus.UNPROCESSABLE_ENTITY))
        .onErrorResume(CannotTransferSameAccount.class,
            basicErrorHandler(resp, HttpResponseStatus.UNPROCESSABLE_ENTITY));
  }

  private <E extends Exception> Function<E, Mono<? extends Publisher<Void>>> basicErrorHandler(
      HttpServerResponse resp, HttpResponseStatus notFound) {
    return (err) -> {
      APIError error = new APIError(err.getMessage());
      return Mono.just(resp.status(notFound)
          .sendString(Mono.just(error).map(gson::toJson)));
    };
  }

  public static void main(String[] args) {
    var dataConfig = createDataConfig();
    var conn = createDB(dataConfig);
    var dao = new AccountDAOImpl(conn, dataConfig);
    var controller = new AccountController(dao);
    var app = new App(controller);
    app.run();
  }

  private static DataConfig createDataConfig() {
    InputStream configIS = ClassLoader.getSystemResourceAsStream("data.toml");
    Toml toml = new Toml().read(configIS);
    return toml.to(DataConfig.class);
  }

  private static Sql2o createDB(DataConfig config) {
    ConnectionConfig c = config.connection;
    return new Sql2o(c.url, c.user, c.password);
  }

  private Mono<?> createAccount(HttpServerRequest req, HttpServerResponse resp) {
    return req.receive()
        .asString()
        .map(str -> gson.fromJson(str, CreateAccountRequest.class))
        .singleOrEmpty()
        .flatMap(accountController::createAccount);
  }

  private Mono<?> getAccount(HttpServerRequest req, HttpServerResponse res) {
    var id = Long.valueOf(req.param("accountID"));
    return accountController.getAccount(id);
  }

  private Mono<?> createDeposit(HttpServerRequest req, HttpServerResponse res) {
    return req.receive()
        .asString()
        .map(str -> {
          CreateDepositRequest obj = gson
              .fromJson(str, CreateDepositRequest.class);
          obj.setAccountID(
              Long.valueOf(Objects.requireNonNull(req.param("accountID"))));
          return obj;
        })
        .singleOrEmpty()
        .flatMap(accountController::createDeposit);
  }

  private Mono<?> createTransfer(HttpServerRequest req, HttpServerResponse res) {
    return req.receive()
        .asString()
        .map(str -> {
          CreateTransferRequest obj = gson
              .fromJson(str, CreateTransferRequest.class);
          obj.setFromAccount(
              Long.valueOf(Objects.requireNonNull(req.param("fromAccount"))));
          return obj;
        })
        .singleOrEmpty()
        .flatMap(accountController::createTransfer)
        .log("create-transfer");
  }
}

@Data
@AllArgsConstructor
class APIError {

  public final String message;
}